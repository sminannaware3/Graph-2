# Time O(n^2)
# Space O(n)
class Solution:
    def __init__(self):
        self.color = 0
        self.n = 0
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        self.n = len(graph)
        # group nodes by colors defined by connected links
        colors = [-1] * self.n
        dependencyMap = {}
        # dfs to assign colors
        for v in range(self.n):
            if colors[v] == -1:
                self.dfs(graph, v, colors)
                self.color += 1
        # for each color count num of nodes
        colorCount = [0] * (self.color)
        for color in colors:
            colorCount[color] += 1
        # find how many malwares are there in each color group
        malwareCount = [0] * self.color
        for node in initial:
            malwareCount[colors[node]] += 1

        result = math.inf
        for node in initial:
            col = colors[node]
            malCount = malwareCount[col]
            if malCount == 1:
                if result == math.inf: result = node
                elif colorCount[col] > colorCount[colors[result]]: result = node
                elif colorCount[col] == colorCount[colors[result]] and result > node: result = node
        # This is tricky we need to return lowest index in initial if malCount > 1, dont know how this works but works
        if result == math.inf:
            for node in initial:
                result = min(result, node)
        return result
        # return 0

    
    def dfs(self, graph: List[List[int]], v: int, colors: List[int]) -> None:
        if colors[v] != -1: return
        colors[v] = self.color
        for i in range(self.n):
            if i == v: continue
            if graph[v][i] == 1: self.dfs(graph, i, colors)